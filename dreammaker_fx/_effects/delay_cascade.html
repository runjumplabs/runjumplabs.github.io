---
layout: default
name: delay_cascade
effect_type: delay-based-effects
---
<pre>
#include <dm_fx.h>

fx_delay  stage1(250.0, 1000.0, 0.8, 1.0, false);
fx_delay  stage2(500.0, 1000.0, 0.7, 1.0, false);
fx_delay  stage3(1000.0, 1000.0, 0.6, 1.0, false);

fx_biquad_filter  filt1(200.0, FILTER_WIDTH_VERY_NARROW, BIQUAD_TYPE_BPF);
fx_biquad_filter  filt2(600.0, FILTER_WIDTH_VERY_NARROW, BIQUAD_TYPE_BPF);
fx_biquad_filter  filt3(900.0, FILTER_WIDTH_VERY_NARROW, BIQUAD_TYPE_BPF);



fx_mixer_4  mix4;
fx_gain gain(0.8);

void setup() {
  
  // put your setup code here, to run once:
  pedal.init();

  // for template, just pass audio from input to output jack
  pedal.route_audio(pedal.instr_in, stage1.input);
  pedal.route_audio(pedal.instr_in, stage2.input);
  pedal.route_audio(pedal.instr_in, stage3.input);
  
  pedal.route_audio(stage1.output, filt1.input);
  pedal.route_audio(stage2.output, filt2.input);
  pedal.route_audio(stage3.output, filt3.input);

  pedal.route_audio(filt1.output, mix4.input_1);
  pedal.route_audio(filt2.output, mix4.input_2);
  pedal.route_audio(filt3.output, mix4.input_3);
  pedal.route_audio(pedal.instr_in, mix4.input_4);
  
  pedal.route_audio(mix4.output, gain.input);
  pedal.route_audio(gain.output, pedal.amp_out);

  // Optional code to print out the routing details to console
  if (true) {
    pedal.print_instance_stack();
    pedal.print_routing_table();
    pedal.print_param_tables();
  }
  // Run this effect
  pedal.run();
  digitalWrite(PIN_FOOTSW_LED_1, HIGH); // Turn on LED as pedal starts on
  
}
  
void loop() {

  // Add an event if pot 0 has changed
  if (pedal.pot_0.has_changed()) { 
    Serial.println(pedal.pot_0.val);
  } 

  // Add an event if pot 1 has changed
  if (pedal.pot_1.has_changed()) { 
    Serial.println(pedal.pot_1.val);
  } 

  // Add an event if pot 2 has changed (DOESN'T WORK ON FIRST GEN HARDWARE YET)
  if (pedal.pot_2.has_changed()) { 
    Serial.println(pedal.pot_2.val);
  } 

  // Strobe Arduino LED once per second
  static int now = millis();
  if (millis() > now + 500) {
    now = millis();
    digitalWrite(PIN_ARD_LED, !digitalRead(PIN_ARD_LED));
  }
  
  // Service 
  pedal.service();
}


// Footswitch 1 - typically used for enable/bypass
void footswitch_1_pressed() { 
  
  // Declared as static so state is preserved between calls
  static bool bypassed = false;

  // Bypass code
  if (bypassed) {
    // If we are currently bypassed, switch pedal to active mode and turn on LED next to SW1
    pedal.enable_fx();
    digitalWrite(PIN_FOOTSW_LED_1, HIGH); // Turn on LED
  } else {
    // If we are currently active, switch pedal to bypassed mode and turn off LED next to SW1
    pedal.bypass_fx();
    digitalWrite(PIN_FOOTSW_LED_1, LOW);  // Turn off LED
  }
  bypassed = !bypassed; // Toggle bypassed state variable
}

// Footswitch 2 - add code here to handle what SW2 does
void footswitch_2_pressed() { 
  
}

// User PB on PCB - add code here to handle what the User PB on the PCB does
void user_pb_pressed() { 
  Serial.println("\nUser PB pressed");
}

</pre>
